文件的相对路径：Makefile
文件内容：
# Makefile
# 获取CPU核心数，用于并行编译
NPROCS = $(shell nproc || sysctl -n hw.ncpu || echo 2)
MAKEFLAGS += -j$(NPROCS)

# 设置本地 LLVM 和 Clang 的路径
LLVM_HOME := /opt/homebrew/opt/llvm

# 使用本地的 clang++
CLANG := $(LLVM_HOME)/bin/clang++
CLANG_FLAGS := -std=c++17 -fno-color-diagnostics -fno-rtti

# 使用本地的 llvm-config
LLVM_CONFIG := $(LLVM_HOME)/bin/llvm-config
LLVM_CXXFLAGS := $(shell $(LLVM_CONFIG) --cxxflags)
LLVM_LDFLAGS := $(shell $(LLVM_CONFIG) --link-shared --ldflags)
LLVM_LIBS := $(shell $(LLVM_CONFIG) --link-shared --libs)
LLVM_SYSTEM_LIBS := $(shell $(LLVM_CONFIG) --system-libs)
LLVM_INCLUDEDIR := $(shell $(LLVM_CONFIG) --includedir)

# Clang 的包含目录和库
CLANG_INCLUDEDIR := $(LLVM_HOME)/include
CLANG_LIBS := -lclang-cpp

# 项目目录结构
SRC_DIR := src
INC_DIR := include
RUNTIME_DIR := runtime
BUILD_DIR := build
BIN_DIR := bin

# 合并所有编译选项
TOOL_CLANG_FLAGS := $(CLANG_FLAGS) $(LLVM_CXXFLAGS) -I$(CLANG_INCLUDEDIR) -I$(INC_DIR)
TOOL_LINK_FLAGS := -L$(LLVM_HOME)/lib -Wl,-rpath,$(LLVM_HOME)/lib $(LLVM_LDFLAGS) $(LLVM_LIBS) $(CLANG_LIBS) $(LLVM_SYSTEM_LIBS)

# 在运行时指定资源目录
ARGS := -resource-dir=$(LLVM_HOME)/lib/clang/19

# 源文件和目标文件
SRCS := $(SRC_DIR)/CallGraph.cpp \
        $(SRC_DIR)/TimeInstrumentation.cpp \
        $(SRC_DIR)/main.cpp
OBJS := $(SRCS:$(SRC_DIR)/%.cpp=$(BUILD_DIR)/%.o)

# 目标文件
TARGET := $(BIN_DIR)/mt3000-inst

.PHONY: all build clean install

all: build

build: $(TARGET)

$(TARGET): $(OBJS) | $(BIN_DIR)
	$(CLANG) $(TOOL_CLANG_FLAGS) -o $@ $^ $(TOOL_LINK_FLAGS)

$(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp | $(BUILD_DIR)
	@mkdir -p $(dir $@)
	$(CLANG) $(TOOL_CLANG_FLAGS) -c $< -o $@

$(BIN_DIR) $(BUILD_DIR):
	mkdir -p $@

install: $(TARGET)
	install -d $(DESTDIR)/usr/local/bin
	install -m 755 $(TARGET) $(DESTDIR)/usr/local/bin
	install -d $(DESTDIR)/usr/local/include/mt3000-inst
	install -m 644 $(RUNTIME_DIR)/*.h $(DESTDIR)/usr/local/include/mt3000-inst

clean:
	rm -rf $(BUILD_DIR) $(BIN_DIR)

# 运行目标程序
run: build
	@echo "Running mt3000-inst..."
	export LD_LIBRARY_PATH=$(LLVM_HOME)/lib:$$LD_LIBRARY_PATH; \
	$(TARGET) $(ARGS) $(RUN_ARGS)-------

文件的相对路径：include/TimeInstrumentation.h
文件内容：
#ifndef TIME_INSTRUMENTATION_H
#define TIME_INSTRUMENTATION_H

#include "clang/AST/AST.h"
#include "clang/AST/ASTConsumer.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/Basic/SourceManager.h"
#include "clang/Rewrite/Core/Rewriter.h"
#include "CallGraph.h"
#include "../runtime/TimeProfiler.h"
#include <unordered_set>

class TimeInstrumentationVisitor : public clang::RecursiveASTVisitor<TimeInstrumentationVisitor> {
public:
    explicit TimeInstrumentationVisitor(clang::Rewriter& R, const CallGraph& CG)
        : rewriter(R), callGraph(CG) {}

    // 必要的AST访问函数
    bool shouldVisitImplicitCode() const { return false; }
    bool shouldVisitTemplateInstantiations() const { return false; }
    bool shouldTraversePostOrder() const { return true; }

    // 访问函数声明
    bool VisitFunctionDecl(clang::FunctionDecl* func);

    // 访问函数调用
    bool VisitCallExpr(clang::CallExpr* call);

    // 结果生成
    std::string generateResultProcessing() const;

private:
    clang::Rewriter& rewriter;
    const CallGraph& callGraph;
    std::unordered_set<std::string> alreadyDeclaredFuncs;  // 跟踪已声明的函数

    // 辅助函数
    void insertTimingCode(clang::FunctionDecl* func, bool isStart);
    void insertCallTimingCode(clang::CallExpr* call, bool isStart);
    bool shouldInstrument(const clang::FunctionDecl* func) const;
};

class TimeInstrumentationConsumer : public clang::ASTConsumer {
public:
    explicit TimeInstrumentationConsumer(clang::Rewriter& R) : rewriter(R) {}

    void HandleTranslationUnit(clang::ASTContext& Context) override;

private:
    clang::Rewriter& rewriter;
    CallGraph callGraph;
};

#endif // TIME_INSTRUMENTATION_H-------

文件的相对路径：include/CallGraph.h
文件内容：
#ifndef CALL_GRAPH_H
#define CALL_GRAPH_H

#include <string>
#include <vector>
#include <memory>
#include <unordered_map>
#include <unordered_set>
#include "clang/AST/AST.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/Basic/SourceLocation.h"
#include "clang/Basic/SourceManager.h"

class CallGraphNode {
public:
    explicit CallGraphNode(const std::string& name) : functionName(name) {}

    void addCallee(std::shared_ptr<CallGraphNode> callee) {
        callees.push_back(callee);
    }

    const std::string& getName() const { return functionName; }
    const std::vector<std::shared_ptr<CallGraphNode>>& getCallees() const { return callees; }

private:
    std::string functionName;
    std::vector<std::shared_ptr<CallGraphNode>> callees;
};

class CallGraph {
public:
    void addNode(const std::string& name);
    void addEdge(const std::string& caller, const std::string& callee);
    std::shared_ptr<CallGraphNode> getNode(const std::string& name) const;
    std::vector<std::string> getRootFunctions() const;
    bool isLeafFunction(const std::string& name) const;
    const std::vector<std::string>& getCallers(const std::string& name) const;
    void clear();
    void dump() const;

private:
    std::unordered_map<std::string, std::shared_ptr<CallGraphNode>> nodes;
    std::unordered_map<std::string, std::vector<std::string>> callers;  // 反向边
};

class CallGraphBuilder : public clang::RecursiveASTVisitor<CallGraphBuilder> {
public:
    explicit CallGraphBuilder(CallGraph& g) : graph(g) {}

    bool VisitFunctionDecl(clang::FunctionDecl* func);
    bool VisitCallExpr(clang::CallExpr* call);

    // 添加必要的遍历控制函数
    bool shouldVisitImplicitCode() const { return false; }
    bool shouldVisitTemplateInstantiations() const { return false; }

private:
    CallGraph& graph;
    std::string currentFunction;
};

#endif // CALL_GRAPH_H-------

文件的相对路径：print_files.sh
文件内容：
#!/bin/bash

# 输出文件名
output_file="all_files_content.txt"

# 清空或创建输出文件
> "$output_file"

# 递归查找所有文件并处理，忽略 .git 和 .vscode 目录
find . -type f ! -path "*.git/*"  ! -path "*.idea/*" ! -path "./build/*" ! -path "./bin/*" ! -path "print_files.sh" ! -path "README.md" ! -path "*doc/*" ! -path "*.vscode/*" ! -name "$output_file" -print0 | while IFS= read -r -d '' file; do
    # 跳过二进制文件和特殊文件
    if file "$file" | grep -q "text"; then
        # 写入文件路径
        echo "文件的相对路径：${file:2}" >> "$output_file"
        echo "文件内容：" >> "$output_file"
        # 写入文件内容
        cat "$file" >> "$output_file"
        # 写入分隔符
        echo "-------" >> "$output_file"
        echo "" >> "$output_file"
    fi
done

echo "处理完成，结果保存在 $output_file"-------

文件的相对路径：runtime/TimeProfiler.h
文件内容：
#ifndef TIME_PROFILER_H
#define TIME_PROFILER_H

#ifdef __cplusplus
extern "C" {
#endif

    // MT-3000设备端函数声明
    unsigned int get_thread_id(void);
    unsigned long get_clk(void);
    int hthread_printf(const char *format, ...);

    // 时间单位换算宏（时钟频率为4150MHz）
#define CLK_FREQ 4150000000UL
#define CYCLES_TO_NS(cycles) ((cycles) * 1000000000UL / CLK_FREQ)
#define CYCLES_TO_US(cycles) ((cycles) * 1000000UL / CLK_FREQ)
#define CYCLES_TO_MS(cycles) ((cycles) * 1000UL / CLK_FREQ)

#ifdef __cplusplus
}
#endif

#endif // TIME_PROFILER_H-------

文件的相对路径：src/TimeInstrumentation.cpp
文件内容：
#include "TimeInstrumentation.h"
#include <sstream>
#include <functional>
#include <string>
#include <cstdio>

namespace {
    constexpr unsigned NUM_THREADS = 24;
    constexpr double DEFAULT_TOTAL_TIME_THRESHOLD = 0.20;    // 20%
    constexpr double DEFAULT_PARENT_TIME_THRESHOLD = 0.40;   // 40%

    // 生成记录时间的全局数组声明
    std::string generateTimeArrayDecl(const std::string& funcName) {
        std::stringstream ss;
        ss << "static unsigned long __time_" << funcName << "[" << NUM_THREADS << "] = {0};\n";
        ss << "static unsigned long __count_" << funcName << "[" << NUM_THREADS << "] = {0};\n";
        return ss.str();
    }

    // 生成获取函数总时间的代码
    std::string generateGetTotalTimeFunc() {
        std::stringstream ss;
        ss << "static inline unsigned long __get_total_time(unsigned long time_array[" << NUM_THREADS << "]) {\n"
           << "    unsigned long max_time = 0;\n"
           << "    for(int i = 0; i < " << NUM_THREADS << "; i++) {\n"
           << "        if(time_array[i] > max_time) max_time = time_array[i];\n"
           << "    }\n"
           << "    return max_time;\n"
           << "}\n\n";
        return ss.str();
    }
}

bool TimeInstrumentationVisitor::shouldInstrument(const clang::FunctionDecl* func) const {
    if (!func->hasBody()) return false;
    return true;  // 暂时默认所有函数都需要插桩
}

void TimeInstrumentationVisitor::insertTimingCode(clang::FunctionDecl* func, bool isStart) {
    std::string funcName = func->getNameAsString();
    std::stringstream code;

    if (isStart) {
        code << "{\n"
             << "    const unsigned tid = get_thread_id();\n"
             << "    const unsigned long start_time = get_clk();\n";
    } else {
        code << "{\n"
             << "    const unsigned tid = get_thread_id();\n"
             << "    const unsigned long end_time = get_clk();\n"
             << "    __time_" << funcName << "[tid] += end_time - start_time;\n"
             << "    __count_" << funcName << "[tid]++;\n"
             << "}\n";
    }

    if (isStart) {
        auto loc = func->getBody()->getBeginLoc();
        loc = loc.getLocWithOffset(1);  // 跳过开始的{
        rewriter.InsertText(loc, code.str(), true, true);
    } else {
        auto loc = func->getBody()->getEndLoc();
        loc = loc.getLocWithOffset(-1);  // 在结束的}之前
        rewriter.InsertText(loc, code.str(), true, true);
    }
}

void TimeInstrumentationVisitor::insertCallTimingCode(clang::CallExpr* call, bool isStart) {
    if (const auto* callee = call->getDirectCallee()) {
        if (!shouldInstrument(callee)) return;

        std::string calleeName = callee->getNameAsString();
        std::stringstream code;

        if (isStart) {
            code << "{\n"
                 << "    const unsigned tid = get_thread_id();\n"
                 << "    const unsigned long call_start = get_clk();\n";
        } else {
            code << "{\n"
                 << "    const unsigned tid = get_thread_id();\n"
                 << "    const unsigned long call_end = get_clk();\n"
                 << "    __time_" << calleeName << "[tid] += call_end - call_start;\n"
                 << "}\n";
        }

        auto loc = isStart ? call->getBeginLoc() : call->getEndLoc();
        rewriter.InsertText(loc, code.str(), true, true);
    }
}

bool TimeInstrumentationVisitor::VisitFunctionDecl(clang::FunctionDecl* func) {
    if (!shouldInstrument(func)) return true;

    std::string funcName = func->getNameAsString();
    if (!alreadyDeclaredFuncs.count(funcName)) {
        rewriter.InsertText(func->getBeginLoc(), generateTimeArrayDecl(funcName), true, true);
        alreadyDeclaredFuncs.insert(funcName);
    }

    insertTimingCode(func, true);  // 函数开始
    insertTimingCode(func, false); // 函数结束

    return true;
}

bool TimeInstrumentationVisitor::VisitCallExpr(clang::CallExpr* call) {
    if (const auto* callee = call->getDirectCallee()) {
        if (!shouldInstrument(callee)) return true;

        insertCallTimingCode(call, true);
        insertCallTimingCode(call, false);
    }
    return true;
}

std::string TimeInstrumentationVisitor::generateResultProcessing() const {
    std::stringstream ss;

    // 生成辅助函数
    ss << generateGetTotalTimeFunc();

    // 生成结果处理函数
    ss << "void __print_timing_results() {\n"
       << "    if (get_thread_id() == 0) {\n"
       << "        // 等待其他线程完成\n"
       << "        unsigned long start_wait = get_clk();\n"
       << "        while((get_clk() - start_wait) < (3UL * " << CLK_FREQ << ")); // 等待3秒\n"
       << "        hthread_printf(\"\\nGenerating timing results...\\n\");\n"
       << "        unsigned long total_time = 0;\n\n";

    // 为每个检测过的函数生成时间统计代码
    for (const auto& funcName : alreadyDeclaredFuncs) {
        ss << "        unsigned long total_" << funcName << " = __get_total_time(__time_" << funcName << ");\n";
        if (callGraph.getRootFunctions().size() == 1 &&
            callGraph.getRootFunctions()[0] == funcName) {
            ss << "        total_time = total_" << funcName << ";\n";
        }
    }

    // 层次化显示函数调用关系和时间统计
    ss << "\n        hthread_printf(\"\\nFunction Call Hierarchy and Timing:\\n\");\n"
       << "        hthread_printf(\"================================\\n\");\n";

    // 递归打印函数调用层次
    std::function<void(const std::string&, int, unsigned long)> printFuncStats;
    printFuncStats = [&](const std::string& funcName, int level, unsigned long parentTime) {
        ss << "        {\n"
           << "            unsigned long func_time = total_" << funcName << ";\n"
           << "            double percent_total = total_time > 0 ? (double)func_time / total_time * 100.0 : 0.0;\n"
           << "            double percent_parent = parentTime > 0 ? (double)func_time / parentTime * 100.0 : 0.0;\n"
           << "            for(int i = 0; i < " << level << "; i++) hthread_printf(\"│   \");\n"
           << "            hthread_printf(\"%s%s: %lu cycles (%.2f%% of total%s)\\n\", "
           << (level > 0 ? "├── " : "")
           << ", \"" << funcName << "\", func_time, percent_total"
           << ", (level > 0 ? \", %.2f%% of parent\" : \"\"), percent_parent);\n"
           << "        }\n";

        // 递归处理被调用函数
        auto node = callGraph.getNode(funcName);
        if (node) {
            for (const auto& callee : node->getCallees()) {
                if (alreadyDeclaredFuncs.count(callee->getName())) {
                    printFuncStats(callee->getName(), level + 1, parentTime);
                }
            }
        }
    };

    // 从根函数开始打印
    for (const auto& rootFunc : callGraph.getRootFunctions()) {
        if (alreadyDeclaredFuncs.count(rootFunc)) {
            printFuncStats(rootFunc, 0, 0);
        }
    }

    // 输出热点函数
    ss << "\n        hthread_printf(\"\\nHot Functions:\\n\");\n"
       << "        hthread_printf(\"=============\\n\");\n";

    for (const auto& funcName : alreadyDeclaredFuncs) {
        if (funcName == callGraph.getRootFunctions()[0]) continue;
        ss << "        {\n"
           << "            unsigned long func_time = total_" << funcName << ";\n"
           << "            double percent_total = (double)func_time / total_time * 100.0;\n";

        for (const auto& caller : callGraph.getCallers(funcName)) {
            if (alreadyDeclaredFuncs.count(caller)) {
                ss << "            unsigned long parent_time = total_" << caller << ";\n"
                   << "            double percent_parent = (double)func_time / parent_time * 100.0;\n"
                   << "            if (percent_total >= 20.0 && percent_parent >= 40.0) {\n"
                   << "                hthread_printf(\"" << funcName << "\\n\")\n"
                   << "                hthread_printf(\"  Total time: %lu cycles (%.2f%% of total)\\n\", "
                   << "func_time, percent_total);\n"
                   << "                hthread_printf(\"  Parent (" << caller << "): %.2f%%\\n\", "
                   << "percent_parent);\n"
                   << "            }\n";
            }
        }
        ss << "        }\n";
    }

    ss << "    }\n"  // 结束tid==0的判断
       << "}\n";     // 结束函数

    return ss.str();
}

void TimeInstrumentationConsumer::HandleTranslationUnit(clang::ASTContext& Context) {
    // 构建调用图
    CallGraphBuilder graphBuilder(callGraph);
    graphBuilder.TraverseDecl(Context.getTranslationUnitDecl());

    // 创建访问器并遍历AST
    TimeInstrumentationVisitor visitor(rewriter, callGraph);
    visitor.TraverseDecl(Context.getTranslationUnitDecl());

    // 在文件末尾添加时间统计处理代码
    auto loc = rewriter.getSourceMgr().getLocForEndOfFile(rewriter.getSourceMgr().getMainFileID());
    rewriter.InsertText(loc, visitor.generateResultProcessing(), true, true);
}-------

文件的相对路径：src/CallGraph.cpp
文件内容：
#include "CallGraph.h"
#include <iostream>
#include <stack>
#include <queue>

void CallGraph::addNode(const std::string& name) {
    if (nodes.find(name) == nodes.end()) {
        nodes[name] = std::make_shared<CallGraphNode>(name);
    }
}

void CallGraph::addEdge(const std::string& caller, const std::string& callee) {
    // 添加节点（如果不存在）
    addNode(caller);
    addNode(callee);

    // 添加调用关系
    nodes[caller]->addCallee(nodes[callee]);

    // 记录反向边
    callers[callee].push_back(caller);
}

std::shared_ptr<CallGraphNode> CallGraph::getNode(const std::string& name) const {
    auto it = nodes.find(name);
    return (it != nodes.end()) ? it->second : nullptr;
}

std::vector<std::string> CallGraph::getRootFunctions() const {
    std::vector<std::string> roots;
    for (const auto& pair : nodes) {
        const std::string& funcName = pair.first;
        if (callers.find(funcName) == callers.end() || callers.at(funcName).empty()) {
            roots.push_back(funcName);
        }
    }
    return roots;
}

bool CallGraph::isLeafFunction(const std::string& name) const {
    auto node = getNode(name);
    return node && node->getCallees().empty();
}

void CallGraph::clear() {
    nodes.clear();
    callers.clear();
}

void CallGraph::dump() const {
    std::cout << "Call Graph Structure:\n";
    for (const auto& pair : nodes) {
        const std::string& funcName = pair.first;
        const auto& callees = pair.second->getCallees();

        std::cout << funcName << " calls:";
        for (const auto& callee : callees) {
            std::cout << " " << callee->getName();
        }
        std::cout << "\n";
    }
}

bool CallGraphBuilder::VisitFunctionDecl(clang::FunctionDecl* func) {
    if (func->hasBody()) {
        currentFunction = func->getNameAsString();
        graph.addNode(currentFunction);
    }
    return true;
}

bool CallGraphBuilder::VisitCallExpr(clang::CallExpr* call) {
    if (!currentFunction.empty()) {
        if (const auto* callee = call->getDirectCallee()) {
            std::string calleeName = callee->getNameAsString();
            graph.addEdge(currentFunction, calleeName);
        }
    }
    return true;
}

const std::vector<std::string>& CallGraph::getCallers(const std::string& name) const {
    static const std::vector<std::string> empty;
    auto it = callers.find(name);
    return (it != callers.end()) ? it->second : empty;
}-------

文件的相对路径：src/main.cpp
文件内容：
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include "clang/Frontend/FrontendActions.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Basic/SourceManager.h"
#include "llvm/Support/CommandLine.h"
#include "TimeInstrumentation.h"
#include <memory>
#include <string>

using namespace clang::tooling;
using namespace llvm;
using namespace clang;

// 命令行选项
static cl::OptionCategory ToolCategory("MT-3000 Instrumentation Tool Options");

static cl::opt<bool> EnableTimeInst(
    "time-inst",
    cl::desc("Enable time instrumentation"),
    cl::init(false),
    cl::cat(ToolCategory));

static cl::opt<bool> EnableMemoryInst(
    "memory-inst",
    cl::desc("Enable memory access instrumentation"),
    cl::init(false),
    cl::cat(ToolCategory));

static cl::opt<double> TotalTimeThreshold(
    "total-time-threshold",
    cl::desc("Threshold for total execution time percentage (default: 20%)"),
    cl::init(20.0),
    cl::cat(ToolCategory));

static cl::opt<double> ParentTimeThreshold(
    "parent-time-threshold",
    cl::desc("Threshold for parent function time percentage (default: 40%)"),
    cl::init(40.0),
    cl::cat(ToolCategory));

static cl::opt<std::string> OutputFilename(
    "o",
    cl::desc("Specify output filename"),
    cl::value_desc("filename"),
    cl::cat(ToolCategory));

class InstrumentationFrontendAction : public clang::ASTFrontendAction {
public:
    InstrumentationFrontendAction() {}

    std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(
        clang::CompilerInstance &CI, llvm::StringRef file) override {
        rewriter.setSourceMgr(CI.getSourceManager(), CI.getLangOpts());
        if (EnableTimeInst) {
            return std::make_unique<TimeInstrumentationConsumer>(rewriter);
        }
        // TODO: 添加访存插桩的支持
        llvm::errs() << "Error: Memory instrumentation not implemented yet.\n";
        return nullptr;
    }

    void EndSourceFileAction() override {
        const auto &ID = rewriter.getSourceMgr().getMainFileID();
        std::string outputName;

        if (!OutputFilename.empty()) {
            outputName = OutputFilename;
        } else {
            auto inputPath = llvm::sys::path::filename(
                rewriter.getSourceMgr().getFilename(rewriter.getSourceMgr().getLocForStartOfFile(ID)));
            outputName = "instrumented_" + inputPath.str();
        }

        std::error_code EC;
        llvm::raw_fd_ostream outFile(outputName, EC, llvm::sys::fs::OF_None);

        if (EC) {
            llvm::errs() << "Error: Could not create output file " << outputName
                        << ": " << EC.message() << "\n";
            return;
        }

        // 获取重写后的代码
        const clang::RewriteBuffer *RewriteBuf = rewriter.getRewriteBufferFor(ID);
        if (RewriteBuf) {
            outFile << std::string(RewriteBuf->begin(), RewriteBuf->end());
            llvm::outs() << "Successfully generated instrumented file: " << outputName << "\n";
        } else {
            llvm::errs() << "Error: No rewrite buffer for main file\n";
        }
    }

private:
    clang::Rewriter rewriter;
};

class InstrumentationFrontendActionFactory : public clang::tooling::FrontendActionFactory {
public:
    std::unique_ptr<clang::FrontendAction> create() override {
        return std::make_unique<InstrumentationFrontendAction>();
    }
};

int main(int argc, const char **argv) {
    // 解析命令行参数
    auto ExpectedParser = CommonOptionsParser::create(argc, argv, ToolCategory);
    if (!ExpectedParser) {
        llvm::errs() << ExpectedParser.takeError();
        return 1;
    }
    CommonOptionsParser& OptionsParser = ExpectedParser.get();
    ClangTool Tool(OptionsParser.getCompilations(), OptionsParser.getSourcePathList());

    // 检查是否指定了任何插桩类型
    if (!EnableTimeInst && !EnableMemoryInst) {
        llvm::errs() << "Error: Must specify at least one instrumentation type "
                     << "(-time-inst or -memory-inst)\n";
        return 1;
    }

    // 检查是否同时指定了多个插桩类型
    if (EnableTimeInst && EnableMemoryInst) {
        llvm::errs() << "Error: Cannot enable both time and memory instrumentation simultaneously\n";
        return 1;
    }

    // 打印工具信息和配置
    llvm::outs() << "MT-3000 Source Code Instrumentation Tool\n";
    llvm::outs() << "======================================\n";
    if (EnableTimeInst) {
        llvm::outs() << "Mode: Time Instrumentation\n";
        llvm::outs() << "Settings:\n";
        llvm::outs() << "  - Total Time Threshold: " << TotalTimeThreshold << "%\n";
        llvm::outs() << "  - Parent Time Threshold: " << ParentTimeThreshold << "%\n";
    } else {
        llvm::outs() << "Mode: Memory Access Instrumentation\n";
    }
    llvm::outs() << "\n";

    // 运行工具
    return Tool.run(std::make_unique<InstrumentationFrontendActionFactory>().get());
}-------

